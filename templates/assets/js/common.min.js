(()=>{var __webpack_modules__={"./src/js/common.js":()=>{eval("\nfunction expandCategoryTree(tree) {\n  for (var i = 0; i < tree.length; i++) {\n    // console.log(tree [i])\n    var $li = $(tree[i])\n    // 获取a元素\n    var $category = $li.children().eq(0)\n    var cur_href = $category.attr('href')\n    var is_href = false\n    const { href, pathname } = location\n    // console.log('href, pathname, cur_href:',href ,cur_href)\n    if (pathname === cur_href) {\n      // 当前连接为该分类，若存在ul，这展开该ul\n      // console.log('找到连接:href, pathname, cur_href:',href,pathname ,cur_href)\n      is_href = true\n    }\n    // 是否存在ul\n    var $ulElements = $li.children('ul')\n    // console.log('$ulElements:',$ulElements)\n    if (is_href) {\n      if ($ulElements.length > 0) {\n        // 分类找到且存在子菜单则展开\n        console.log('cur_href,cur----ulElements:', cur_href, $ulElements)\n        $category.addClass('arrow-dropdown')\n        $ulElements.addClass('expand')\n      }\n      console.log('cur_href,cur----category:', cur_href, $category)\n      // 选择当前分类\n      $category.addClass('current')\n      return true\n    } else if ($ulElements.length > 0) {\n      // 分类未找到且存在ul则继续递归找\n      if (expandCategoryTree($ulElements.children())) {\n        $ulElements.addClass('expand')\n        $category.addClass('arrow-dropdown')\n        console.log('未找到分类：cur_href,cur----$category:', cur_href, $category)\n        return true\n      }\n    }\n  }\n  return false\n}\n\nconst commonContext = {\n\n  /* 初始化目录和公告模块 */\n  initTocAndNotice() {\n    const { pathname } = location\n    window.tocPjax && window.tocPjax()\n    let hideToc = $('.widget.toc .card-content ul').length === 0\n\n\n    let hideNotice = (themeConfig.notice_show_mode === 'toc' && !hideToc)\n      || (themeConfig.notice_show_mode === 'index' && pathname !== '/')\n    console.log('themeConfig.notice_show_mode,hideToc,hideNotice,pathname:', themeConfig.notice_show_mode, hideToc,hideNotice,pathname)\n    if (hideToc) {\n      $('.widget.toc,.action-toc').addClass('is-hidden-all')\n    } else {\n      $('.widget.toc,.action-toc').removeClass('is-hidden-all')\n    }\n    if (hideNotice) {\n      $('.widget.notice').addClass('is-hidden-all')\n    } else {\n      console.log('removeClass notice:',  $('.widget.notice'))\n      $('.widget.notice').removeClass('is-hidden-all')\n    }\n  },\n  // testaaa() {\n  //   console.log('Hello, this is a debug log!')\n  // },\n  /* 激活图片预览功能 */\n  initGallery() {\n    // 用链接和标题包装图像\n    $('.main-content img:not(.not-gallery)').each(function () {\n      if ($(this).parents('[data-fancybox],mew-photos').length === 0) {\n        $(this).wrap(`<div class=\"0\"><div data-fancybox=\"gallery\" ${this.alt ? `data-caption=\"${this.alt}\"` : ''} href=\"${$(this).attr('src')\n        }\"></div>${(this.alt && themeConfig.show_img_name) ? `<p>${this.alt}</p>` : ''}</div>`)\n      }\n    })\n  },\n  /* 实现当前菜单高亮 */\n  initNavbar() {\n    const $nav_menus = $('.navbar-nav a')\n    const $nav_side_menus = $('.panel-side-menu .link')\n    let activeIndex = 0\n    const { href, pathname } = location\n\n    if (pathname && pathname !== '/') {\n      for (let i = 0; i < $nav_menus.length; i++) {\n        const cur_href = $nav_menus[i].getAttribute('href')\n        if (pathname.includes(cur_href) || href.includes(cur_href)) {\n          activeIndex = i\n          if (pathname === cur_href || href === cur_href) break\n        }\n      }\n    }\n\n    // 高亮PC端\n    const $curMenu = $nav_menus.eq(activeIndex)\n    // 点击菜单后，将该菜单设置current高亮css，不需要移除逻辑，因为每次点击都是重新渲染新的html页面\n    // 因此要实现侧边栏分类树，在点击后重新请求新的页面，同样要处理相应的分类树选择逻辑\n    $curMenu.addClass('current')\n    if ($curMenu.parents('.item-dropdown').length) {\n      $curMenu\n        .parents('.item-dropdown')\n        .find('.item-dropdown-link a')\n        .addClass('current')\n    }\n\n    // 高亮移动端\n    $nav_side_menus.eq(activeIndex).addClass('current')\n  },\n  /* 激活导航栏全局下拉框功能 */\n  // initDropMenu() {\n  //   $('.item-dropdown').each(function (index, item) {\n  //     const menu = $(this).find('.item-dropdown-menu')\n  //     const trigger = $(item).attr('trigger') || 'click'\n  //     const placement = $(item).attr('placement') || $(this).height() || 0\n  //     menu.css('top', placement)\n  //     if (trigger === 'hover') {\n  //       $(this).hover(\n  //         () => $(this).addClass('active'),\n  //         () => $(this).removeClass('active')\n  //       )\n  //     } else {\n  //       $(this).on('click', function (e) {\n  //         e.stopPropagation()\n  //         $(this).toggleClass('active')\n  //         $(document).one('click', () => $(this).removeClass('active'))\n  //         e.stopPropagation()\n  //       })\n  //       menu.on('click', (e) => e.stopPropagation())\n  //     }\n  //   })\n  // }\n  /** 分类树初始化 */\n  initCategoryTree() {\n    const $categories_Tree = $('.card.widget.categories > ul > li')\n    // console.log('$categories_Tree:', $categories_Tree)\n    expandCategoryTree($categories_Tree)\n  }\n}\n\n// 在现代JavaScript开发中，我们倾向于使用模块来封装代码，以保持全局命名空间的清洁和避免命名冲突。\n// 然而，在某些情况下，你可能需要让某个函数在全局作用域中可用，以便它可以被来自不同模块或第三方库的代码访问。\n// 这时，将函数赋值给window对象是一个可行的解决方案。\n// window.commonContext = commonContext\n\n!(function () {\n  // 若没有将common放到body最后，需要再html加载完后执行菜单高亮才行\n  const loads = ['initCarousel', 'sparkInput', 'websiteTime', 'initNavbar', 'initCategoryTree','initTocAndNotice']\n  const omits = ['initEffects', 'loadMaintain', 'showThemeVersion']\n\n  Object.keys(commonContext).forEach(\n    (c) => !loads.includes(c) && !omits.includes(c) && commonContext[c]()\n  )\n\n  // 当前html加载完执行\n  document.addEventListener('DOMContentLoaded', function () {\n    $('html').addClass('loaded')\n    loads.forEach((c) => commonContext[c] && commonContext[c]())\n  })\n\n  // 所有内容加载完执行\n  window.addEventListener('load', function () {\n    omits.forEach((c) => commonContext[c] && commonContext[c]())\n    $('html').addClass('ready')\n  })\n})()\n\n//# sourceURL=webpack://as-rust-blog-theme1.0/./src/js/common.js?")}},__webpack_exports__={};__webpack_modules__["./src/js/common.js"]()})();